---
title: "[백준 2156] 포도주 시식 파이썬 풀이 - DP"
date: 2023-08-21 20:55:00 +0900
categories: [알고리즘, DP]
tags: [dp, 백준]
---

![main-img](/assets/img/boj-logo.png)

## 문제

### 문제 링크 : [백준 2156](https://www.acmicpc.net/problem/2156)

![문제](/assets/img/boj-2156/2156-0.png)
<br>

규칙은

1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

---

## 접근

DP 문제로 전에 풀었던 [[백준 2579] 계단오르기 파이썬 풀이 - DP](https://tgkim.com/posts/boj-2579) 와 거의 비슷하다.
<br>
다른 점은 최대의 합이 아니라면 **마지막 잔을 마시지 않아도 되는 것**이다.
<br>

3잔 연속의 규칙을 지키면서 마지막 잔을 포함하지 않아도 된다는 점을 생각해서 접근했다.

---

## 풀이

문제의 예시 데이터를 이용해서 규칙을 찾아봤다. 점화식을 찾기위해..
<br>

1. a는 예시 데이터가 들어있는 list이다.
2. dp(i)는 i위치까지의 합을 나타낸다.

![풀이1](/assets/img/boj-2156/2156-1.jpeg){: width="600" height="400"}

나는 dp(2)를 통해서 규칙을 찾는 힌트를 얻었다.
<br>
그리고dp(3)부터는 일정한 규칙을 따르며, 점화식을 구할 수 있게 되었다.
<br>
<br>

dp(i)의 i위치까지의 합을 구하는데 나올 수 있는 방법은 세 가지가 있다.
<br>
![풀이2](/assets/img/boj-2156/2156-2.jpeg){: width="600" height="400"}

위의 세 가지 경우 중 가장 큰 수를 dp(i)에 채택한다.
<br>
따라서 점화식은 **<span style="color:red">dp(n) = max ( dp(n-1), dp(n-2) + a[n], dp(n-3) + a[n-1] + a[n] )</span>** 이다.

### 정답 코드

```python
# 2156
import sys

input = sys.stdin.readline

n = int(input())
a = [0] * 10000
dp = [0] * 10000
for i in range(n):
  a[i] = int(input())

dp[0] = a[0]
dp[1] = a[0] + a[1]
dp[2] = max(dp[1], a[0] + a[2], a[1] + a[2])
for i in range(3, n):
  dp[i] = max(dp[i - 1], dp[i - 2] + a[i], dp[i - 3] + a[i - 1] + a[i])
print(dp[n - 1])
```

<br>

---

## 느낀점

계단 오르기 문제에서 살짝의 변형이 들어갔다.
<br>
처음에 풀 땐 아래와 같이 n만큼 선언해줬다.

```python
a = [0] * n
dp = [0] * n
```

문제의 최대 잔의 개수는 1부터 10000까지 이기때문에 미리 10000만큼 선언해줘도 된다.
<br>아니, 해줘야 편할 수 있다.
<br>왜냐하면 잔의 개수는 1, 3도 될 수 있다. 그렇다면 코드 13,14번째 라인을 실행할 때 인덱스 에러가 발생한다.
<br>
<br>물론 조건을 통해 미리 걸러줘도 되지만 코드가 길어지고 보기에 복잡해질 수 있다.
<br>크게 어려운 점은 없지만 **배열이 엄청나게 크지 않다면 문제의 최대만큼 선언해주면 효율적일 수 있다.**
